#!/usr/bin/perl

use v5.16;
use utf8;
binmode(STDOUT, ':encoding'.($ENV{'LANG'}? '(utf8)': '(cp-866)') );

use Demonstrator;



our @exs =
(   #{=======================================================




sub {
    N 0                                        ;
#   -----------

=for comment

  Регулярное выражение R описывает вид ПОДСТРОКИ строки $s для поиска ($s=~m/R/) или замены ($s=~s/R/S/).
  R - это последовательность шаблонов, каждый из которых кроме задания правила сопоставления для текущей
  позиции рассматриваемой строки определяет и сдвиги позиции и шаблона для дальнейшего сопоставления как
  при успехе, так и неудаче.
                                Общая структура шаблона:
    [КЛАСС_СИМВОЛОВ]ПОВТОР   [^КЛАСС_СИМВОЛОВ]ПОВТОР     КЛАСС_ПОЗИЦИИ
    (R1|R2|...)ПОВТОР  задаёт альтернативное сопоставление из последовательностей шаблонов.
  
  КЛАСС_СИМВОЛОВ определяет множество символов, которые могут стоять на текущей позиции. Когда множество
  из одного символа, то скобки [] можно не писать. [^КЛАСС_СИМВОЛОВ] задаёт множество, дополняющее
  множество [КЛАСС_СИМВОЛОВ] до множества всех символов (мощностью несколько десятков тысяч).
    [][0-9-] - это множество, содержащее символы ']','[','0','1','2','3','4','5','6','7','8','9' и '-' .
  
                                Некоторые специальные сокращения записи классов:
    . - все символы, кроме \n       \N - все символы, кроме \n
    \d - цифры     \w - буквы, цифры, подчеркивание     \s - пробельные символы     \S - непробельные символы
  
  Следует помнить, что трактовка специальных классов зависит от кодировки и регулируется модификаторами
  команд, в которых используется R.
  
  ПОВТОР - это {МИН,МАКС} или {МИН,}, где МИН и МАКС - числа, но возможны следующие синтаксические сокращения:
    отсутвует ~{1,1}       ? ~{0,1}    * ~{0,}    + ~{1,}    {МИН} ~{МИН,МИН}
    
  При МИН!=МАКС сопоставление задаваемое шаблоном "жадное", т.е. сопоставляется с каждой следующей позицией
  строки столько, сколько может (однако не больше МАКС), но "отзывчивое", т.е. пока не останется лишь МИН,
  отдаёт выбранный ранее символ, если идущий следом шаблон не сопоставился. Идущий после такого повтора
  символ ? делает шаблон "скромным", т.е. начинающим с меньшего указанного и "по просьбе" берущий на один символ
  больше. Символ +, идущий после такого повтора в дополнение к ? или сам по себе, отключает "отзывчивость".
  Отключение "отзывчивости" - это очень хорошая оптимизация работы регулярного выражения, которую автоматически
  провести довольно сложно, но делать её надо осмотрительно.

  КЛАСС_ПОЗИЦИИ определяет шаблон для позиции между символами.
    ^ - начало строки   $ - конец строки    \b - граница идентификатора     \B - не граница идентификатора
    \A - до начального символа     \z - после последнего символа    \Z - перед завершающим \n или после последнего
    \G - конец предыдущего сопоставления m//g
  Здесь при сопоставлении текущая позиция строки не сдвигается.

    Сводка специальных символов в R:     [] () . ^ $ | \      + * ? {}
    
    Пустой шаблон соотвествует любой строке!  "dа" =~ / ( a*+ b?+ с{0,3} | a ) /x даст 1, но в $1 будет пустая строка.
  
  Конструкция (R1) не только задаёт группу шаблонов, для которых можно написать повтор, но и обеспечивает захват
  в специальные переменные $1, $2, ... той части строки, что C:\Roperl>perl -I. exs4re.pl 1сопоставилась с попавшим в группу подвыражением R1.
  Группы захвата использует соответствующую её номеру переменную, а номера группам назначаются согласно следованию
  открывающихся скобок слева направо. Можно использовать конструкцию (?<имя>R1), которая обеспечивает захват
  сопоставившихся переменных ещё в специальные хеш-массивы %+ и %-, где ключом будут заданные имена. Указанные
  переменные можно использовать после команды сопоставления или замены, что и делает эти команды эффективным
  инструментом для разбора, анализа и консолидации текстовых данных. Конструкция (?:R1) или модификатор n
  запрещают захват для одной или всех конструкций вида (R1).
    
=cut

},




sub {
    N 1                                        ;
#   -----------  RegExpr:  (=)=~     s/[]//ug

    my ($sr, @sr, $t1, $t2);
    
    $sr = ($t1 = 'Чящя - мой учясток. Щявель кое-где растёт.')    =~ s/(Ч|ч|Щ|щ)я/$1а/ug;
    @sr = ($t2 = 'Такие разные жывотные. Жыли-были шыло и мыло.') =~ s/([ЖжШш])ы/$1и/ug;
    say "$sr: $t1\n";
    say "@sr: $t2\n";

},




sub {
    N 2                                        ;
#   -----------  RegExpr:  s///g vs tr///
    use Benchmark qw(cmpthese :hireswallclock);

    my ($it, $t);
    my ($are, $cre, $nre) = (qr/а|б/, qr/[аб]/, qr/ю|я/);       # транслируем регулярные выражения
    my @pr = (
        'y/аб/вв/  '  => sub { ($t=$it)=~y/аб/вв/;    }, # транслитерации с совпадениями
        'y/юя/вв/  '  => sub { ($t=$it)=~y/юя/вв/;    }, #          и без совпадений
        's/ю|я/в/g '  => sub { ($t=$it)=~s/ю|я/в/g;   }, # замены без совпадений
        's/$nre/в/g'  => sub { ($t=$it)=~s/$nre/в/og; }, # 
        's/а|б/в/g '  => sub { ($t=$it)=~s/а|б/в/g;   }, #      и с совпадениями
        's/[аб]/в/g'  => sub { ($t=$it)=~s/[аб]/в/g;  },
        's/$are/в/g'  => sub { ($t=$it)=~s/$are/в/og; },
        's/$cre/в/g'  => sub { ($t=$it)=~s/$cre/в/og; },
    );


    $it = join '', map { (qw(а б д))[int(rand(3))] }  1..50;    # генерируем случайную строку алфавита из 3 символов

    for(my $i=0; $i<@pr; $i+=2 ) {                              # выводим результат замен       
        my ($k,$p_r) = @pr[$i,$i+1];
        $p_r->();
        say "$k: $t";
    }

    say'   Wait a minute';     cmpthese(  100000,  { @pr[ 8..$#pr ] }  );       # выводим скорость работы для s///
    say'   Wait a minute';     cmpthese( 5000000,  { @pr[ 0..7    ] }  );       # и y///
    
},




sub {
    N 3                                       ;
#   -----------  RegExpr:  = =~     s/() \s+ \1/$1/xug

    my ($sr, @sr, $t);
                                           # На косогоре с небрежно заплетёнными в косу волосами косоглазый
                                           # выпивший человек кривой косой косил траву и опьянел окончательно.
    $t  = 'На горке косой с косой косой косой косой косой косой косил траву и окосел окончательно.';
    
    $sr = $t =~ s/(\w+) \s+ \g{1}/$1/xug;  # убирает повторы парами;    вместо \g{1} можно \1  (perlre)
    say "$sr: $t\n";
                                            #   В английском:
                                            # It is true that that 'that that' that that man used
                                            # in that sentence is wrong.

},




sub {
    N 4                                       ;
#   -----------  RegExpr:  qr/\d [-]/xan     s/$re//oxuge;

    my ($sr, $t, $a_re);
    
    $a_re = qr/  (?:\d | [.=+*()-])+  /xa;  # qr/  (\d | [.=+*()-])+  /xan;
    
    $sr = ($t = 'Посчитайте 10+15*3, 2.5*2.+.5 и 4-6. Завтра спрошу.')   =~ s/($a_re)
                                                                             / $1 . '=' . eval($1)
                                                                             /oxuge;
    say "$sr: $t\n";

},




sub {
    N 5                                        ;
#   -----------  RegExpr:  qr/\N{}/i

    my ($st, $t, @a_re);
    
    $t = "При fi=PI/2 и FI=-PI/2 cos(\N{LATIN SMALL LIGATURE FI}) равно 0.";
    @a_re = (   qr/   fi                     /xu,
                qr/   fi                     /xui,
                qr/  (f)(i) | [fi]{2} | fi+  /xui,
            );

    while( my ($i,$re) = each @a_re ) {
        ($st = $t)  =~ s/$re/psi/g;         say "$i: $st\n";
    }

},




sub {
    N 6                                        ;
#   -----------  RegExpr:  qr    []{,}    /()/uxgo

    my (@ar,  $sr,      $ss1, $ss2, $ss3);
    
    my   $re  =  qr/ ( [а-яё]{4,} ([а-яё]) )  ([,;]) /ux;        # 4(или больше) буквы    буква    , или ;

    my    $t  =  'взморье, песок; сосны, солнце';

            @ar = $t =~ / $re /xgo;
                ($ss1, $ss2, $ss3)  =  ($1, $2, $3);
                                                say "(@ar)      ($ss1 $ss2 $ss3)";

    while(  $sr = $t =~ / $re /xgo  )           {
                ($ss1, $ss2, $ss3)  =  ($1, $2, $3);
                                                say "($sr)      ($ss1 $ss2 $ss3)";
                                                }
                                                say "($sr)      ($ss1 $ss2 $ss3)";

},




sub {
    N 7                                        ;
#   -----------  printf     RegExpr:  qr    [Ёё]{,}    /(?<имя>)/ugx    %+  %-

    my $title =
<<'EOT';

    По каждому текстовому элементу осуществляется сопоставление
    сначала в скалярном контексте, а потом списковом и выдается  (где 
        T  - текст элемента,
        S  - результат поиска в скалярном контексте,
        A  - результат (как число) поиска в списковом контексте,
        K+ - список ключей хеша %+ после поиска в списковом контексте,
        K- - список ключей хеша %- после поиска в списковом контексте)
    строка вида

        T : S |$1 $2 $3|$+{sl} $+{sp}|    (A)|$+{al} $+{ap}|    K+     | K-
    
EOT
    
    my ($sr, @sr);
    my    @t = qw(барка,  взморье,песок;сосны,солнце  море;   мумиё,мумиё;);
    
    my $s_re = qr/  [а-я]{3,} (?<sl>[а-я] ) (?<sl>[а-я] ) (?<sp>[,;]) /ux;
    my $a_re = qr/ [а-яё]{3,} (?<al>[а-яё]) (?<al>[а-яё]) (?<ap>[,;]) /ux;

                                say $title;
    for(@t){
        $sr = /$s_re/ugo;       printf( '%26s : %d %-4s%-6s',
                                        $_, 0+$sr, "|$1 $2 $3", "|@+{qw(sl sp)}|"
                                      );
        @sr = /$a_re/ugo;       printf( '%14s%-8s   ',
                                        "(@sr)",  "|@+{qw(al ap)}|"
                                      );
                                    local $,=' '; #$";
                                say   keys %+, (keys(%+)<2?'   ':''), '   |', keys %-;
    }

},




);  #}=======================================================


my $d = new Demonstrator( $0, \@exs );
$d->work();


__END__

=head1 NAME

 ops.pl    - Demonstrator of Perl operations and operators.

There are an array of text examples in 'for'.

=head1 SYNOPSYS

 perl ops.pl        - to demonstrate all examples
 perl ops.pl N      - to demonstrate the N-th example
 perl ops.pl N1 N2  - to demonstrate the examples from N1 to N2

=cut
